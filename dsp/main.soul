// vim: set ft=cpp:

graph Groovebox [[ main ]] {
    input event soul::midi::Message midiIn;
    input stream float<2> audioIn;

    output sequencer.exportMidi midiOut;
    output stream float<2> audioOut;

    let sequencer = Sequencer();
    let enferVoices = EnferVoice[8];
    let voiceAllocator = soul::voice_allocators::Basic(8);

    connection {
        midiIn -> soul::midi::MPEParser -> sequencer;
        sequencer.playKit -> voiceAllocator -> enferVoices -> audioOut;
    }
}

processor Sequencer {
    input event (soul::note_events::NoteOn,
                 soul::note_events::NoteOff) midiIn;

    output event soul::note_events::NoteOn playKit;
    output event soul::midi::Message exportMidi;

    int currentTrack = 0;
    soul::note_events::NoteOn[64] steps;

    bool kit = true;
    int keyboardRoot = 60;
    bool[12] keyboardScale = scale::major;

    bool playing = false;
    bool armed = false;

    int currentNote16 = 0;
    soul::timeline::Tempo tempo;
    soul::timeline::TimeSignature signature;

    void init () {
        tempo = soul::timeline::Tempo(120.0);
        signature = soul::timeline::TimeSignature(4, 4);
    }

    void run() {
        loop {
            dump();
            let step = steps[wrap<steps.size>(currentNote16)];
            if (playing && step.velocity > 0)
                playKit << step;
            loop(int(soul::timeline::framesPerQuarterNote(tempo, signature, processor.frequency)) / 4)
                advance();
            if (playing)
                currentNote16++;
        }
    }

    void dump() {
        setBeat();
        setTrack();
        setArmed();
        if (kit) setKit();
        else setKey();
    }

    int currentNote4() {
        return currentNote16 / 4;
    }

    /*
     * (ab)use midi for i/o with the web ui
     */

    const int noModifier = 60;
    const int shift      = 61;
    const int alt        = 62;

    event midiIn(soul::note_events::NoteOn message) {
        let keyIndex = int(message.note);
        let left = bool(message.channel);
        let right = !left;
        let modifier = roundToInt(message.velocity * 127) >> 1;

        if (right && modifier == shift && keyIndex == 14) {
            playing = !playing;
            if (!playing)
                currentNote16 = 0;
        }

        if (right && modifier == shift && keyIndex == 9) {
            armed = !armed;
            setArmed();
        }

        else if (right && modifier == noModifier) {
            let note = soul::note_events::NoteOn(0, float(keyIndex), 1.0);
            playKit << note;
            if (armed && playing)
                steps[wrap<steps.size>(currentNote16)] = note;
        }
    }

    event midiIn(soul::note_events::NoteOff message) {
    }

    void setBeat() {
        exportMidi << soul::midi::Message(playing ? currentNote4() % 16 : 16);
    }

    void setTrack() {
        exportMidi << soul::midi::Message(1 << 16 | currentTrack);
    }

    void setKit() {
        exportMidi << soul::midi::Message(2 << 16);
    }

    void setKey() {
        int scaleBits = 0;
        for (wrap<keyboardScale.size> i)
            if (keyboardScale[i])
                scaleBits |= 2 ^ i;
        exportMidi << soul::midi::Message(3 << 16 | keyboardRoot << 12 | scaleBits);
    }

    void setArmed() {
        exportMidi << soul::midi::Message(4 << 16 | int(armed));
    }
}

processor EnferVoice {
    output stream float<2> audioOut;

    input event soul::note_events::NoteOn midiIn;

    int kit = -1;
    int sample = -1;
    int playbackPosition;

    event midiIn(soul::note_events::NoteOn e) {
        kit = int(e.channel);
        sample = int(e.note);
        playbackPosition = 0;
    }

    void run() {
        loop {
            audioOut << enfer::play(kit, sample, playbackPosition);
            playbackPosition++;
            advance();
        }
    }
}
