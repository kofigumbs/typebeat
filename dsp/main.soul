// vim: set ft=cpp:

graph Groovebox [[ main ]] {
    input event soul::midi::Message midiIn;
    input stream float<2> audioIn;

    output controller.globalMidiOut midiOut;
    output stream float<2> audioOut;

    let controller = sequence::Controller();
    let enferVoices = EnferVoice[8];
    let voiceAllocator = soul::voice_allocators::Basic(8);

    connection {
        midiIn -> soul::midi::MPEParser -> controller;
        controller.kitOut -> voiceAllocator -> enferVoices -> audioOut;
    }
}

namespace sequence {
    const int resolution = 128;

    struct Position {
        int value;
    }

    void next(Position& p) { p.value += 1; }
    void reset(Position& p) { p.value = 0; }

    int toNthNote(Position p, int subdivision) {
        return subdivision * p.value / resolution;
    }

    Position toPosition(int n, int subdivision) {
        return Position(n * resolution / subdivision);
    }

    bool subdivides(int n, Position p) {
        return p.value == p.toNthNote(n).toPosition(n).value;
    }

    int resolutionInFrames(soul::timeline::Tempo tempo, float64 sampleRate) {
        return int(soul::timeline::framesPerBeat(tempo, sampleRate)) / (resolution/4);
    }

    int quantize(Position p, int subdivision) {
        let stepLength = resolution/subdivision;
        return (p.value + stepLength/2)/ stepLength;
    }

    struct Step {
        bool[15] hits;
    }

    struct Track {
        Step[resolution] steps;
    }

    void hit(Step& step, int note, bool toggle) {
        step.hits[wrap<step.hits.size>(note)] = !toggle || !step.hits[wrap<step.hits.size>(note)];
    }

    void record(Track& track, int step, int note, bool toggle) {
        hit(track.steps[wrap<track.steps.size>(step)], note, toggle);
    }

    processor Controller {
        input event (soul::note_events::NoteOn,
                     soul::note_events::NoteOff) midiIn;

        output event soul::note_events::NoteOn kitOut;
        output event soul::midi::Message globalMidiOut;

        Track track;
        int currentTrack = 0;
        int quantizeSubdivision = 32;
        Position position;
        bool playing;
        bool armed;
        int keyboardRoot = 60;
        bool[12] keyboardScale = scale::major;

        int lastHit;
        soul::timeline::Tempo tempo;

        void init () {
            tempo = soul::timeline::Tempo(180.0);
        }

        void run() {
            loop {
                // sync ui
                setBeat();
                setTrack();
                setArmed();
                setKit();

                // busy wait if sequence is stopped
                while(!playing)
                    advance();

                // play any sounds on this step
                if ((quantizeSubdivision).subdivides(position)) {
                    let step = track.steps[wrap<track.steps.size>(position.toNthNote(quantizeSubdivision))];
                    for (wrap<step.hits.size> i)
                        if (step.hits[i])
                            playKit(i);
                }

                // move sequence position with resolution rate
                loop (resolutionInFrames(tempo, processor.frequency))
                    advance();
                if (playing)
                    position.next();
            }
        }

        void playKit(int sample) {
            // TODO earmark sample index-15 for fx4 since they don't otherwise fit
            kitOut << soul::note_events::NoteOn(0, float(sample), 1.0);
        }

        /*
         * (ab)use midi for internal control protocol
         */

        struct Key {
            bool left;
            int index;
            int modifier;
        }

        Key parse(int channel, float note, float velocity) {
            return Key(
                bool(channel),
                int(note),
                roundToInt(velocity * 127) >> 1
            );
        }

        const int noModifier = 60;
        const int shift      = 61;
        const int alt        = 62;

        const int undefined = -1;

        bool trigger(Key k) { return k.modifier == noModifier && !k.left; }
        bool togglePlay(Key k) { return k.modifier == shift && !k.left && k.index == 14; }
        bool toggleArm(Key k) { return k.modifier == shift && !k.left && k.index == 9; }

        int sequenceStep(Key k) {
            if (k.modifier != shift)      return undefined;
            if (k.left  && k.index == 11) return  0;
            if (k.left  && k.index == 12) return  1;
            if (k.left  && k.index == 13) return  2;
            if (k.left  && k.index == 14) return  3;
            if (!k.left && k.index == 10) return  4;
            if (!k.left && k.index == 11) return  5;
            if (!k.left && k.index == 12) return  6;
            if (!k.left && k.index == 13) return  7;
            if (k.left  && k.index ==  6) return  8;
            if (k.left  && k.index ==  7) return  9;
            if (k.left  && k.index ==  8) return 10;
            if (k.left  && k.index ==  9) return 11;
            if (!k.left && k.index ==  5) return 12;
            if (!k.left && k.index ==  6) return 13;
            if (!k.left && k.index ==  7) return 14;
            if (!k.left && k.index ==  8) return 15;
                                          return undefined;
        }

        event midiIn(soul::note_events::NoteOn message) {
            let key = parse(message.channel, message.note, message.velocity);

            if (key.togglePlay()) {
                playing = !playing;
                if (!playing) position.reset();
                return;
            }

            if (key.toggleArm()) {
                armed = !armed;
                return;
            }

            if (key.trigger()) {
                lastHit = key.index;
                playKit(lastHit);
                if (armed && playing) track.record(position.quantize(quantizeSubdivision), lastHit, false);
                return;
            }

            let step = key.sequenceStep();
            if (step != undefined) {
                track.record(step.toPosition(16).value, lastHit, true);
                if (!playing) playKit(lastHit);
                return;
            }
        }

        void setBeat() {
            globalMidiOut << soul::midi::Message(playing ? position.toNthNote(4) % 16 : 16);
        }

        void setTrack() {
            globalMidiOut << soul::midi::Message(1 << 16 | currentTrack);
        }

        void setKit() {
            globalMidiOut << soul::midi::Message(2 << 16);
        }

        void setKey() {
            int scaleBits = 0;
            for (wrap<keyboardScale.size> i)
                if (keyboardScale[i])
                    scaleBits |= 2 ^ i;
            globalMidiOut << soul::midi::Message(3 << 16 | keyboardRoot << 12 | scaleBits);
        }

        void setArmed() {
            globalMidiOut << soul::midi::Message(4 << 16 | int(armed));
        }

    }
}

processor EnferVoice {
    output stream float<2> audioOut;

    input event soul::note_events::NoteOn midiIn;

    int kit = -1;
    int sample = -1;
    int playbackPosition;

    event midiIn(soul::note_events::NoteOn e) {
        if (e.velocity <= 0) return;
        kit = int(e.channel);
        sample = int(e.note);
        playbackPosition = 0;
    }

    void run() {
        loop {
            audioOut << enfer::play(kit, sample, playbackPosition);
            playbackPosition++;
            advance();
        }
    }
}
