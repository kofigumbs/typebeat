// vim: set ft=cpp:

graph Groovebox [[ main ]] {
    input event soul::midi::Message midiIn;
    input stream float<2> audioIn;

    output controller.globalMidiOut midiOut;
    output stream float<2> audioOut;

    let controller = sequence::Controller();
    let enferVoices = EnferVoice[8];
    let voiceAllocator = soul::voice_allocators::Basic(8);

    connection {
        midiIn -> soul::midi::MPEParser -> controller;
        controller.noteOut -> voiceAllocator -> enferVoices -> audioOut;
    }
}

namespace sequence {
    const int resolution = 128;

    struct Position {
        int value;
    }

    void next(Position& p) { p.value += 1; }
    void reset(Position& p) { p.value = 0; }

    int toNthNote(Position p, int subdivision) {
        return subdivision * p.value / resolution;
    }

    Position toPosition(int n, int subdivision) {
        return Position(n * resolution / subdivision);
    }

    bool subdivides(int n, Position p) {
        return p.value == p.toNthNote(n).toPosition(n).value;
    }

    int resolutionInFrames(soul::timeline::Tempo tempo, float64 sampleRate) {
        return int(soul::timeline::framesPerBeat(tempo, sampleRate)) / (resolution/4);
    }

    int quantize(Position p, int subdivision) {
        let stepLength = resolution/subdivision;
        return (p.value + stepLength/2)/ stepLength;
    }

    struct Hit {
        bool delay;
        bool trigger;
    }

    struct Step {
        Hit[15] hits;
    }

    struct Track {
        Step[resolution] steps;
    }

    void recordHit(Step& step, int note, Hit hit) {
        step.hits[wrap<step.hits.size>(note)] = hit;
    }

    void record(Track& track, int step, int note, Hit hit) {
        recordHit(track.steps.at(step), note, hit);
    }

    processor Controller {
        input event (soul::note_events::NoteOn,
                     soul::note_events::NoteOff) midiIn;

        output event (soul::note_events::NoteOn,
                      soul::note_events::NoteOff) noteOut;
        output event soul::midi::Message globalMidiOut;

        Track track;
        bool kit = false;
        int currentTrack = 0;
        int currentKit = 0;
        int currentSynth = 0;
        int currentRoot = 60;
        keyboard::Layout currentScale = keyboard::scale::major;

        Position position;
        bool playing;
        bool armed;
        int lastSample;
        int quantizeSubdivision = 32;
        soul::timeline::Tempo tempo;

        void init () {
            tempo = soul::timeline::Tempo(180.0);
        }

        void run() {
            loop {
                // sync ui
                setBeat();
                setTrack();
                setArmed();
                if (kit) setKit();
                else setKey();

                // busy wait if sequence is stopped
                if (!playing) {
                    loop (resolutionInFrames(tempo, processor.frequency))
                        advance();
                    continue;
                }

                // trigger notes on this step
                if ((quantizeSubdivision).subdivides(position))
                    playStep(track.steps[wrap<track.steps.size>(position.toNthNote(quantizeSubdivision))]);

                // move sequence position with resolution rate
                loop (resolutionInFrames(tempo, processor.frequency))
                    advance();
                if (playing)
                    position.next();
            }
        }

        void playStep(Step& step) {
            for (wrap<step.hits.size> i) {
                if (step.hits[i].delay)
                    step.hits[i] = Hit(false, step.hits[i].trigger);
                else if (step.hits[i].trigger)
                    play(i);
            }
        }

        void play(int i) {
            if (!kit)
                noteOut << soul::note_events::NoteOn(currentSynth, float(currentRoot + currentScale.valueOf(keyboard::Key(true, i, keyboard::unused))), 2);
            else if (currentKit == 13)
                // last kit is specialized for fx4 since it's otherwise unplayable
                noteOut << soul::note_events::NoteOn(i, 15, 1);
            else
                noteOut << soul::note_events::NoteOn(currentKit, float(i), 1);
        }

        /*
         * (ab)use midi for internal control protocol
         */

        keyboard::Key parse(int channel, float note, float velocity) {
            return keyboard::Key(
                bool(channel),
                int(note),
                roundToInt(velocity * 127) >> 1
            );
        }

        bool isTrigger(keyboard::Key k)      { return k.modifier == keyboard::unused && k.right; }
        bool isTogglePlay(keyboard::Key k)   { return k.modifier == 10 /* q */ && k.right && k.index == 14 /* p */; }
        bool isToggleArm(keyboard::Key k)    { return k.modifier == 10 /* q */ && k.right && k.index == 9 /* ; */; }
        bool isSetOctave(keyboard::Key k)    { return k.modifier == 14 /* t */ && k.right; }
        bool isSequenceStep(keyboard::Key k) { return k.modifier == 10 /* q */ && keyboard::sequence::steps.uses(k); }

        event midiIn(soul::note_events::NoteOn message) {
            let key = parse(message.channel, message.note, message.velocity);

            if (key.isTogglePlay()) {
                playing = !playing;
                if (!playing) position.reset();
            }

            else if (key.isToggleArm()) {
                armed = !armed;
            }

            else if (key.isTrigger()) {
                lastSample = key.index;
                play(lastSample);
                if (armed && playing) {
                    let step = position.quantize(quantizeSubdivision);
                    track.record(step, lastSample, Hit(step > position.value, true));
                }
            }

            else if (key.isSetOctave()) {
                if (kit) currentKit = key.index;
                else currentRoot = key.index;
            }

            else if (key.isSequenceStep()) {
                let step = keyboard::sequence::steps.valueOf(key).toPosition(16).value;
                track.record(step, lastSample, Hit(false, !track.steps.at(step).hits.at(lastSample).trigger));
                if (!playing) play(lastSample);
            }
        }

        void setBeat() {
            globalMidiOut << soul::midi::Message(playing ? position.toNthNote(4) % 16 : 16);
        }

        void setTrack() {
            globalMidiOut << soul::midi::Message(1 << 16 | currentTrack);
        }

        void setKit() {
            globalMidiOut << soul::midi::Message(2 << 16 | currentKit);
        }

        void setKey() {
            int scaleBits = 0;
            // for (wrap<keyboardScale.size> i)
            //     if (keyboardScale[i])
            //         scaleBits |= 2 ^ i;
            globalMidiOut << soul::midi::Message(3 << 16 | currentRoot << 12 | scaleBits);
        }

        void setArmed() {
            globalMidiOut << soul::midi::Message(4 << 16 | int(armed));
        }
    }
}

processor EnferVoice {
    output stream float<2> audioOut;

    input event soul::note_events::NoteOn midiIn;

    int instrument = -1;
    int note = -1;
    float64 playbackPosition;
    bool kit;

    event midiIn(soul::note_events::NoteOn e) {
        instrument = int(e.channel);
        note = int(e.note);
        playbackPosition = 0;
        kit = e.velocity == 1;
    }

    void run() {
        loop {
            if (kit) {
                audioOut << enfer::playKit(instrument, note, playbackPosition);
                playbackPosition++;
            } else if (note <= 38) {
                audioOut << enfer::playSynth(instrument, 0, playbackPosition);
                playbackPosition += soul::getSpeedRatioForPitchedSample(enfer::sampleRate, 32, processor.frequency, float(note));
            } else {
                audioOut << enfer::playSynth(instrument, 1, playbackPosition);
                playbackPosition += soul::getSpeedRatioForPitchedSample(enfer::sampleRate, 48, processor.frequency, float(note));
            }
            advance();
        }
    }
}
