// vim: set ft=cpp:

graph Groovebox [[ main ]] {
    input event soul::midi::Message midiIn;
    input stream float<2> audioIn;
    output event soul::midi::Message midiOut;
    output stream float<2> audioOut;

    let controller = Controller();
    let voice = Voice();

    connection {
        midiIn -> ui::Decode -> controller;
        controller.uiOut -> ui::Encode ->  midiOut;
        controller.sequenceOut -> Sequence -> voice -> audioOut;
        controller.voiceOut -> voice -> audioOut;
    }
}

processor Controller {
    input event (ui::Decode::RequestSync,
                 ui::Decode::Modify,
                 soul::note_events::NoteOn,
                 soul::note_events::NoteOff) in;
    output event (Voice::SetType,
                  Voice::SetInstrument,
                  soul::note_events::NoteOn,
                  soul::note_events::NoteOff) voiceOut;
    output event (Sequence::MoveTo,
                  Sequence::Record,
                  Sequence::Toggle) sequenceOut;
    output event ui::Encode::State uiOut;

    int frameCount;
    int last4th = -1;
    int last8th = -1;
    ui::Encode::State uiState;
    soul::timeline::Tempo tempo;
    soul::note_events::NoteOn lastNote;

    void init() {
        uiState.root = 60;
        tempo.bpm = 180.0;
    }

    void run() {
        loop {
            if (!uiState.playing) {
                advance();
                continue;
            }
            let current4th = (4).thNote();
            if (current4th != last4th) {
                uiState.position16 = current4th % 16;
                uiOut << uiState;
                last4th = current4th;
            }
            let current8th = (8).thNote();
            if (current8th != last8th) {
                sequenceOut << Sequence::MoveTo(current8th);
                last8th = current8th;
            }
            advance();
            frameCount++;
        }
    }

    int thNote(int subdivision) {
        return int(frameCount / soul::timeline::framesPerBeat(tempo, processor.frequency) * subdivision / 4);
    }

    event in(ui::Decode::RequestSync r) {
        uiOut << uiState;
    }

    event in(ui::Decode::Modify modify) {
        if (modify.q && modify.value == 14) {
            uiState.playing = !uiState.playing;
            if (!uiState.playing) {
                frameCount = 0;
                last4th = -1;
                last8th = -1;
            }
        }
        else if (modify.q && modify.value == 9) {
            uiState.armed = !uiState.armed;
        }
        else if (modify.q && layout::sequence[modify.value] != -1) {
            let step = layout::sequence[modify.value] * 2; // to 8th note
            sequenceOut << Sequence::Toggle(step, lastNote);
            if (!uiState.playing)
                voiceOut << lastNote;
        }
        else if (modify.r && modify.value < Voice::typeCount) {
            uiState.voiceType = int(modify.value);
            voiceOut << Voice::SetType(modify.value);
        }
        else if (modify.t) {
            uiState.instrument = int(modify.value);
            voiceOut << Voice::SetInstrument(modify.value);
        }
        uiOut << uiState;
    }

    event in(soul::note_events::NoteOn midi) {
        midi.channel = uiState.track;
        midi.note = scaleNote(midi.note);
        voiceOut << midi;
        if (uiState.playing && uiState.armed)
            sequenceOut << Sequence::Record(((16).thNote() - 1) / 2, midi);
        lastNote = midi;
    }

    event in(soul::note_events::NoteOff midi) {
        midi.channel = uiState.track;
        midi.note = scaleNote(midi.note);
        voiceOut << midi;
    }

    float scaleNote(float note) {
        if (uiState.voiceType == Voice::synth)
            return float(uiState.root + layout::scales.at(15 * (uiState.scale % 12) + (int(note) % 15)));
        else
            return note;
    }
}

processor Sequence {
    input event (MoveTo,
                 Record,
                 Toggle) in;
    output event (soul::note_events::NoteOff,
                  soul::note_events::NoteOn) out;

    struct MoveTo { int step; }
    struct Record { int step; soul::note_events::NoteOn midi; }
    struct Toggle { int step; soul::note_events::NoteOn midi; }

    struct Step {
        bool trig;
        soul::note_events::NoteOn midi;
    }

    Step[32] steps;

    event in(MoveTo m) {
        let i = wrap<steps.size>(m.step);
        if (steps[i].trig)
            out << steps[i].midi;
    }

    event in(Record r) {
        let i = wrap<steps.size>(r.step);
        steps[i].trig = true;
        steps[i].midi = r.midi;
    }

    event in(Toggle s) {
        let i = wrap<steps.size>(s.step);
        if (steps[i].trig && steps[i].midi.note == s.midi.note) {
            steps[i].trig = false;
        } else {
            steps[i].trig = true;
            steps[i].midi = s.midi;
        }
    }

    void run() {
        loop {
            advance();
        }
    }
}

processor Voice {
    input event (SetType,
                 SetInstrument,
                 soul::note_events::NoteOff,
                 soul::note_events::NoteOn) in;
    output stream float<2> out;

    struct SetType { int type; }
    struct SetInstrument { int instrument; }

    int type;
    const int kit   = 0;
    const int synth = 1;
    const int typeCount  = 2;

    int[typeCount] instruments;
    int sample;
    float64 playbackPosition;
    float64 playbackPositionIncrement;

    event in(SetType s) {
        type = s.type;
    }

    event in(SetInstrument s) {
        instruments[wrap<typeCount>(type)] = s.instrument;
    }

    event in(soul::note_events::NoteOn midi) {
        if (type == kit) {
            sample = int(midi.note);
            playbackPositionIncrement = 1;
        }
        else if (type == synth) {
            sample = int(midi.note > 38);
            playbackPositionIncrement = soul::getSpeedRatioForPitchedSample(
                enfer::sampleRate,
                float(midi.note > 38 ? 48 : 60),
                processor.frequency,
                midi.note
            );
        }
        playbackPosition = 0;
    }

    void run() {
        loop {
            if (type == kit)
                out << enfer::playKit(instruments.at(type), sample, playbackPosition);
            else if (type == synth)
                out << enfer::playSynth(instruments.at(type), sample, playbackPosition);
            playbackPosition += playbackPositionIncrement;
            advance();
        }
    }
}

namespace layout {
    const int[30] sequence = int[30](
        -1, -1, -1, -1, -1, 12, 13, 14, 15, -1,  4, 5, 6, 7, -1, // right
        -1, -1, -1, -1, -1, -1,  8,  9, 10, 11, -1, 0, 1, 2,  3  // left
    );

    const int[12 * 15] scales = int[12 * 15](
        -12, -10, -8, -7, -5, -3, -1, 0, 2, 4, 5, 7, 9, 11, 12,
        -12, -10, -9, -7, -5, -4, -2, 0, 2, 3, 5, 7, 8, 10, 12,
        -12, -10, -9, -7, -5, -3, -2, 0, 2, 3, 5, 7, 9, 10, 12,
        -12, -11, -9, -7, -5, -4, -2, 0, 1, 3, 5, 7, 8, 10, 12,
        -12, -10, -8, -6, -5, -3, -1, 0, 2, 4, 6, 7, 9, 11, 12,
        -12, -10, -8, -7, -5, -3, -2, 0, 2, 4, 5, 7, 9, 10, 12,
        -12, -11, -9, -7, -6, -4, -2, 0, 1, 3, 5, 6, 8, 10, 12,
        -12, -10, -9, -7, -5, -4, -1, 0, 2, 3, 5, 7, 8, 11, 12,
        -12, -10, -8, -7, -5, -4, -1, 0, 2, 4, 5, 7, 8, 11, 12,
        -12, -10, -9, -7, -5, -3, -1, 0, 2, 3, 5, 7, 9, 11, 12,
        -12, -10, -9, -7, -5, -4, -2, 0, 2, 3, 5, 7, 8, 10, 12,
        -12, -10, -8, -7, -5, -4, -2, 0, 2, 4, 5, 7, 8, 10, 12
    );
}
