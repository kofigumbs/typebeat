// vim: set ft=cpp:

graph Groovebox  [[ main ]] {
    input stream float<2> audioIn;
    input event soul::midi::Message midiIn;

    output stream float<2> audioOut;
    output event soul::midi::Message midiOut;

    let monoToStereo = OneToMany(float, 2);

    connection {
        midiIn -> soul::midi::MPEParser -> Kit -> audioOut;
        Timeline -> midiOut;
    }
}

processor Timeline {
    output event soul::midi::Message midiOut;

    int currentQuarterNote = 0;
    soul::timeline::Tempo tempo;
    soul::timeline::TimeSignature signature;
    soul::timeline::TransportState transport;

    void init () {
        tempo = soul::timeline::Tempo(120.0);
        signature = soul::timeline::TimeSignature(4, 4);
        transport = soul::timeline::TransportState(1 /* playing */);
    }

    void run() {
        loop {
            loop(int(soul::timeline::framesPerQuarterNote(tempo, signature, processor.frequency))) {
                advance();
            }
            currentQuarterNote++;
            midiOut << soul::midi::Message(
                242 << 16 /* song position pointer */
                    | ((currentQuarterNote * 4) & 127) << 8 /* least significant 7 bits in 16th notes */
                    | ((currentQuarterNote * 4) >> 7) & 127 /* most significant 7 bits in 16th notes */
            );
        }
    }
}

processor Kit {
    output stream float<2> audioOut;

    input event soul::note_events::NoteOn midiIn;

    float<2>[] sample;
    int samplePlayback;

    event midiIn(soul::note_events::NoteOn e) {
        samplePlayback = 0;
        let kit = enfer::kits().at(e.channel);
        if (e.note ==  0) sample = kit.kick;
        if (e.note ==  1) sample = kit.kickUp;
        if (e.note ==  2) sample = kit.kickDown;
        if (e.note ==  3) sample = kit.tom;
        if (e.note ==  4) sample = kit.snare;
        if (e.note ==  5) sample = kit.snareUp;
        if (e.note ==  6) sample = kit.snareDown;
        if (e.note ==  7) sample = kit.clap;
        if (e.note ==  8) sample = kit.hat;
        if (e.note ==  9) sample = kit.hatOpen;
        if (e.note == 10) sample = kit.hatShut;
        if (e.note == 11) sample = kit.cymb;
        if (e.note == 12) sample = kit.fx1;
        if (e.note == 13) sample = kit.fx2;
        if (e.note == 14) sample = kit.fx3;
        if (e.note == 15) sample = kit.fx4;
    }

    void run() {
        loop {
            if (samplePlayback < sample.size) {
                audioOut << sample.at(samplePlayback);
                samplePlayback++;
            }
            advance();
        }
    }
}

processor SineOsc {
    output stream float audioOut;

    input event (soul::note_events::NoteOn,
                 soul::note_events::NoteOff,
                 soul::note_events::PitchBend) midiIn;

    float notePitch, bendSemitones, phase, phaseIncrement;

    event midiIn(soul::note_events::NoteOn e) {
        notePitch = e.note;
        bendSemitones = 0.0f;
        calculatePhaseIncrement();
    }

    event midiIn(soul::note_events::NoteOff e) {
        if (e.note == notePitch)
            notePitch = 0;
    }

    event midiIn(soul::note_events::PitchBend e) {
        bendSemitones = e.bendSemitones;
        calculatePhaseIncrement();
    }


    void calculatePhaseIncrement() {
        let noteFrequency = soul::noteNumberToFrequency(notePitch + bendSemitones);
        phaseIncrement = float(noteFrequency * twoPi * processor.period);
    }

    void run() {
        loop {
            phase = addModulo2Pi(phase, phaseIncrement);
            audioOut << (notePitch > 0 ? sin(phase) : float(0));
            advance();
        }
    }
}

processor OneToMany(using T, int n) {
    input stream T audioIn;
    output stream T<n> audioOut;

    void run() {
        loop {
            T<n> sample;
            for (wrap<n> i)
                sample[i] = audioIn;
            audioOut << sample;
            advance();
        }
    }
}
